## Copyright (C) 2003-2012, 2014-2018 Free Software Foundation, Inc.
## Written by Keisuke Nishida, Roger While, Simon Sobisch, Ron Norman,
## Brian Tiffin
##
## This file is part of GnuCOBOL.
##
## The GnuCOBOL compiler is free software: you can redistribute it
## and/or modify it under the terms of the GNU General Public License
## as published by the Free Software Foundation, either version 3 of the
## License, or (at your option) any later version.
##
## GnuCOBOL is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with GnuCOBOL.  If not, see <http://www.gnu.org/licenses/>.

### GnuCOBOL Test Suite


AT_SETUP([READ INTO data-item AT-END sequence])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN "./TEST-FILE".
       DATA             DIVISION.
       FILE             SECTION.
       FD  TEST-FILE.
       01  TEST-REC     PIC X(10).
       WORKING-STORAGE  SECTION.
       01  X            PIC X(10).
       PROCEDURE        DIVISION.
           OPEN  OUTPUT TEST-FILE.
           CLOSE TEST-FILE.
           OPEN  INPUT  TEST-FILE.
           READ  TEST-FILE INTO X
               AT END MOVE ALL ZERO TO X
           END-READ.
           CLOSE TEST-FILE.
           IF X NOT = "0000000000"
              DISPLAY "Expected zeros - Got " X
              END-DISPLAY
           END-IF.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([LINAGE and LINAGE-COUNTER sample])
AT_KEYWORDS([runfile optional file status READ WRITE END-OF-PAGE LINE SEQUENTIAL COB_CURRENT_DATE])

# modified version of GC-FAQ: Example of LINAGE File Descriptor
# Author: Brian Tiffin, Date:   10-July-2008

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           select optional data-file assign to 'prog.cob'
               organization is line sequential
               file status is data-file-status.
           select mini-report assign to "mini-report".

       DATA DIVISION.
       FILE SECTION.
       FD  data-file.
       01  data-record.
           88 endofdata        value high-values.
           02 data-line        pic x(80).
       FD  mini-report
           linage is 16 lines
               with footing at 15
               lines at top 2
               lines at bottom 2.
       01  report-line         pic x(80).

       WORKING-STORAGE SECTION.
       01  command-arguments   pic x(1024).
       01  file-name           pic x(160).
       01  data-file-status    pic xx.
       01  lc                  pic 99.
       01  report-line-blank.
           02 filler           pic x(18) value all "*".
           02 filler           pic x(05) value spaces.
           02 filler           pic x(34)
               VALUE "THIS PAGE INTENTIONALLY LEFT BLANK".
           02 filler           pic x(05) value spaces.
           02 filler           pic x(18) value all "*".
       01  report-line-data.
           02 body-tag         pic 9(6).
           02 line-3           pic x(74).
       01  report-line-header.
           02 filler           pic x(6) VALUE "PAGE: ".
           02 page-no          pic 9999.
           02 filler           pic x(24).
           02 filler           pic x(5) VALUE " LC: ".
           02 header-tag       pic 9(6).
           02 filler           pic x(23).
           02 filler           pic x(6) VALUE "DATE: ".
           02 page-date        pic x(6).

       01  page-count          pic 9999.

       PROCEDURE DIVISION.

       open input data-file.
       read data-file
           at end
               display "File open error: " data-file-status
               stop run
       end-read.

       open output mini-report.

       write report-line
           from report-line-blank
       end-write.

       move 1 to page-count.
       accept page-date from date end-accept.
       move page-count to page-no.
       write report-line
           from report-line-header
           after advancing page
       end-write.

       perform readwrite-loop until endofdata.

       display
           "Normal termination, ending status: "
           data-file-status
       close mini-report.

       close data-file.
       stop run.

      ****************************************************************
       readwrite-loop.
       move data-record to report-line-data
       move linage-counter to body-tag
       write report-line from report-line-data
           end-of-page
               add 1 to page-count end-add
               move page-count to page-no
               move linage-counter to header-tag
               write report-line from report-line-header
                   after advancing page
               end-write
       end-write
       read data-file
           at end set endofdata to true
       end-read
       .
])

AT_CAPTURE_FILE([mini-report])
AT_DATA([reference-report], [

******************     THIS PAGE INTENTIONALLY LEFT BLANK     ******************


















PAGE: 0001                         LC: 000000                       DATE: 150206
000001
000002 IDENTIFICATION DIVISION.
000003 PROGRAM-ID. prog.
000004 ENVIRONMENT DIVISION.
000005 INPUT-OUTPUT SECTION.
000006 FILE-CONTROL.
000007     select optional data-file assign to 'prog.cob'
000008         organization is line sequential
000009         file status is data-file-status.
000010     select mini-report assign to "mini-report".
000011
000012 DATA DIVISION.
000013 FILE SECTION.
000014 FD  data-file.





PAGE: 0002                         LC: 000015                       DATE: 150206
000001 01  data-record.
000002     88 endofdata        value high-values.
000003     02 data-line        pic x(80).
000004 FD  mini-report
000005     linage is 16 lines
000006         with footing at 15
000007         lines at top 2
000008         lines at bottom 2.
000009 01  report-line         pic x(80).
000010
000011 WORKING-STORAGE SECTION.
000012 01  command-arguments   pic x(1024).
000013 01  file-name           pic x(160).
000014 01  data-file-status    pic xx.





PAGE: 0003                         LC: 000015                       DATE: 150206
000001 01  lc                  pic 99.
000002 01  report-line-blank.
000003     02 filler           pic x(18) value all "*".
000004     02 filler           pic x(05) value spaces.
000005     02 filler           pic x(34)
000006         VALUE "THIS PAGE INTENTIONALLY LEFT BLANK".
000007     02 filler           pic x(05) value spaces.
000008     02 filler           pic x(18) value all "*".
000009 01  report-line-data.
000010     02 body-tag         pic 9(6).
000011     02 line-3           pic x(74).
000012 01  report-line-header.
000013     02 filler           pic x(6) VALUE "PAGE: ".
000014     02 page-no          pic 9999.





PAGE: 0004                         LC: 000015                       DATE: 150206
000001     02 filler           pic x(24).
000002     02 filler           pic x(5) VALUE " LC: ".
000003     02 header-tag       pic 9(6).
000004     02 filler           pic x(23).
000005     02 filler           pic x(6) VALUE "DATE: ".
000006     02 page-date        pic x(6).
000007
000008 01  page-count          pic 9999.
000009
000010 PROCEDURE DIVISION.
000011
000012 open input data-file.
000013 read data-file
000014     at end





PAGE: 0005                         LC: 000015                       DATE: 150206
000001         display "File open error: " data-file-status
000002         stop run
000003 end-read.
000004
000005 open output mini-report.
000006
000007 write report-line
000008     from report-line-blank
000009 end-write.
000010
000011 move 1 to page-count.
000012 accept page-date from date end-accept.
000013 move page-count to page-no.
000014 write report-line





PAGE: 0006                         LC: 000015                       DATE: 150206
000001     from report-line-header
000002     after advancing page
000003 end-write.
000004
000005 perform readwrite-loop until endofdata.
000006
000007 display
000008     "Normal termination, ending status: "
000009     data-file-status
000010 close mini-report.
000011
000012 close data-file.
000013 stop run.
000014





PAGE: 0007                         LC: 000015                       DATE: 150206
000001****************************************************************
000002 readwrite-loop.
000003 move data-record to report-line-data
000004 move linage-counter to body-tag
000005 write report-line from report-line-data
000006     end-of-page
000007         add 1 to page-count end-add
000008         move page-count to page-no
000009         move linage-counter to header-tag
000010         write report-line from report-line-header
000011             after advancing page
000012         end-write
000013 end-write
000014 read data-file





PAGE: 0008                         LC: 000015                       DATE: 150206
000001     at end set endofdata to true
000002 end-read
000003 .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([COB_CURRENT_DATE="2015/02/06 16:40:52" $COBCRUN_DIRECT ./prog], [0],
[Normal termination, ending status: 10
], [])
AT_CHECK([diff mini-report reference-report], [0], [], [])

AT_CLEANUP


AT_SETUP([First READ on empty SEQUENTIAL INDEXED file])
AT_KEYWORDS([runfile])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS  INDEXED
                        ACCESS MODE  IS  SEQUENTIAL
                        RECORD KEY   IS  TEST-KEY.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-KEY      PIC X(10).
       PROCEDURE        DIVISION.
           OPEN  OUTPUT TEST-FILE.
           CLOSE TEST-FILE.
           OPEN  INPUT  TEST-FILE.
           READ  TEST-FILE
                 AT END
                   CONTINUE
                 NOT AT END
                   DISPLAY "NOT OK"
                   END-DISPLAY
           END-READ.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([READ NEXT without previous START])
AT_KEYWORDS([runfile WRITE indexed])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS  INDEXED
                        ACCESS MODE  IS  SEQUENTIAL
                        RECORD KEY   IS  TEST-KEY.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC.
          05 TEST-KEY      PIC X(10).
          05 TEST-DATA     PIC X.
       PROCEDURE        DIVISION.
           OPEN  OUTPUT TEST-FILE
           MOVE  '1'    TO TEST-KEY
           MOVE  'A'    TO TEST-DATA
           WRITE TEST-REC
           MOVE  '3'    TO TEST-KEY
           MOVE  'B'    TO TEST-DATA
           WRITE TEST-REC
           CLOSE TEST-FILE
           OPEN  INPUT  TEST-FILE
           READ  TEST-FILE NEXT
                 AT END
                   DISPLAY "AT END FOR REC1"
                   END-DISPLAY
                   CLOSE TEST-FILE
                   STOP RUN
                 NOT AT END
                   CONTINUE
           END-READ
           IF TEST-DATA NOT = 'A'
              DISPLAY "WRONG REC1: '" TEST-REC "'"
              END-DISPLAY
           END-IF
           READ  TEST-FILE NEXT
                 AT END
                   DISPLAY "AT END FOR REC2"
                   END-DISPLAY
                   CLOSE TEST-FILE
                   STOP RUN
                 NOT AT END
                   CONTINUE
           END-READ.
           IF TEST-DATA NOT = 'B'
              DISPLAY "WRONG REC2: '" TEST-REC "'"
              END-DISPLAY
           END-IF
           READ  TEST-FILE NEXT
                 AT END
                   CONTINUE
                 NOT AT END
                   DISPLAY "NOT AT END AFTER REC2"
                   END-DISPLAY
           END-READ
           IF TEST-DATA NOT = 'B'
              DISPLAY "DATE CHANGED ON EOF: '" TEST-REC "'"
              END-DISPLAY
           END-IF
           CLOSE TEST-FILE
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([REWRITE a RELATIVE file with RANDOM access])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT TEST-FILE ASSIGN       "./TEST-FILE"
                        ORGANIZATION IS RELATIVE
                        ACCESS MODE  IS RANDOM
                        RELATIVE KEY IS TEST-KEY.
       DATA             DIVISION.
       FILE             SECTION.
       FD TEST-FILE.
       01 TEST-REC      PIC X.
       WORKING-STORAGE  SECTION.
       01 TEST-KEY      PIC 9.
       PROCEDURE        DIVISION.
      *
           OPEN OUTPUT TEST-FILE.
           MOVE 1 TO TEST-KEY.
           MOVE "A" TO TEST-REC.
           WRITE TEST-REC
           END-WRITE.
           MOVE 2 TO TEST-KEY.
           MOVE "B" TO TEST-REC.
           WRITE TEST-REC
           END-WRITE.
           CLOSE TEST-FILE.
      *
           OPEN I-O TEST-FILE.
           MOVE 1 TO TEST-KEY.
           READ TEST-FILE
           END-READ.
           MOVE 2 TO TEST-KEY.
           MOVE "C" TO TEST-REC.
           REWRITE TEST-REC
           END-REWRITE.
           CLOSE TEST-FILE.
      *
           OPEN INPUT TEST-FILE.
           MOVE 1 TO TEST-KEY.
           READ TEST-FILE
           END-READ.
           IF TEST-REC NOT = "A"
              DISPLAY "Expected 'A' - Got " TEST-REC
              END-DISPLAY
           END-IF.
           MOVE 2 TO TEST-KEY.
           READ TEST-FILE
           END-READ.
           IF TEST-REC NOT = "C"
              DISPLAY "Expected 'C' - Got " TEST-REC
              END-DISPLAY
           END-IF.
           CLOSE TEST-FILE.
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([SORT with SD, I/O SEQUENTIAL])
AT_KEYWORDS([runfile using giving])

# Note: We shouldn't use AT_DATA to create sequential record
# data, because AT_DATA needs a \n at the end

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT SORT-IN   ASSIGN "test.txt".
       SELECT SORT-OUT  ASSIGN "result.txt".
       SELECT SORT-WRK  ASSIGN "SORT-WRK".
       DATA             DIVISION.
       FILE             SECTION.
       FD SORT-IN.
       01 IN-REC        PIC X(6).
       FD SORT-OUT.
       01 OUT-REC       PIC X(6).
       SD SORT-WRK.
       01 WRK-REC       PIC X(6).
       PROCEDURE        DIVISION.

      * Special case: write test data in COBOL, see note above
           OPEN OUTPUT SORT-IN.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM "world " END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM "hello " END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           CLOSE SORT-IN.

           SORT SORT-WRK
                ASCENDING KEY WRK-REC
                USING  SORT-IN
                GIVING SORT-OUT.
             STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat result.txt], [0], [                              hello world ], [])

AT_CLEANUP


AT_SETUP([SORT with SD, I/O LINE SEQUENTIAL])
AT_KEYWORDS([runfile using giving])

# Note: We shouldn't use AT_DATA to create sequential record
# data, because AT_DATA needs a \n at the end

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT SORT-IN   ASSIGN "test.txt"
                        ORGANISATION LINE SEQUENTIAL.
       SELECT SORT-OUT  ASSIGN "result.txt"
                        ORGANISATION LINE SEQUENTIAL.
       SELECT SORT-WRK  ASSIGN "SORT-WRK".
       DATA             DIVISION.
       FILE             SECTION.
       FD SORT-IN.
       01 IN-REC        PIC X(20).
       FD SORT-OUT.
       01 OUT-REC       PIC X(20).
       SD SORT-WRK.
       01 WRK-REC       PIC X(6).
       PROCEDURE        DIVISION.

      * Special case: write test data in COBOL, see note above
           OPEN OUTPUT SORT-IN.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM "world " END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM "hello " END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           WRITE IN-REC FROM SPACES   END-WRITE.
           CLOSE SORT-IN.

           SORT SORT-WRK
                ASCENDING KEY WRK-REC
                USING  SORT-IN
                GIVING SORT-OUT.
             STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat result.txt], [0], [




hello
world
], [])

AT_CLEANUP


AT_SETUP([SORT with SD, I/O LINE SEQUENTIAL same file])
AT_KEYWORDS([runfile using giving])

AT_DATA([test.txt], [
bla
world
hello

blubb
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT SORT-IN   ASSIGN "test.txt"
                        ORGANISATION LINE SEQUENTIAL.
       SELECT SORT-WRK  ASSIGN "dummy".
       DATA             DIVISION.
       FILE             SECTION.
       FD SORT-IN.
       01 IN-REC        PIC X(6).
       SD SORT-WRK.
       01 sort-entry    PIC X(6).
       PROCEDURE        DIVISION.

      * We can use normal test data as we want to
      * create a line sequential file.
      *     OPEN OUTPUT SORT-IN.
      *     WRITE IN-REC FROM SPACES   END-WRITE.
      *     WRITE IN-REC FROM "world " END-WRITE.
      *     WRITE IN-REC FROM "hello " END-WRITE.
      *     WRITE IN-REC FROM SPACES   END-WRITE.
      *     CLOSE SORT-IN.

           SORT SORT-WRK
                ASCENDING sort-entry
                USING  SORT-IN
                GIVING SORT-IN.
             STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat test.txt], [0], [

bla
blubb
hello
world
], [])

AT_CLEANUP


AT_SETUP([SORT nonexistent file])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT SORT-IN   ASSIGN "SORT-IN".
       SELECT SORT-OUT  ASSIGN "SORT-OUT".
       SELECT SORT-WRK  ASSIGN "SORT-WRK".
       DATA             DIVISION.
       FILE             SECTION.
       FD SORT-IN.
       01 IN-REC        PIC X(100).
       FD SORT-OUT.
       01 OUT-REC       PIC X(100).
       SD SORT-WRK.
       01 WRK-REC       PIC X(100).
       PROCEDURE        DIVISION.
           SORT SORT-WRK
                ASCENDING KEY WRK-REC
                USING  SORT-IN
                GIVING SORT-OUT.
             STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([cat SORT-OUT], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN with LOCAL-STORAGE item])
AT_KEYWORDS([runfile])

AT_DATA([test.txt],
[hello
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT test-file ASSIGN path
                        ORGANIZATION LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE	            SECTION.
       FD  test-file.
       01  test-rec     PIC X(5).
       LOCAL-STORAGE    SECTION.
       01  path         PIC X(10) VALUE "test.txt".
       PROCEDURE        DIVISION.
           OPEN INPUT test-file
           READ test-file   END-READ
           IF test-rec NOT = "hello"
              DISPLAY test-rec END-DISPLAY
           END-IF
           CLOSE test-file
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN with LOCAL-STORAGE item and INITIAL prog])
AT_KEYWORDS([runfile])

# Files are initialised in a different location in INITIAL program, hence the
# need for a separate test.

AT_DATA([test.txt],
[hello
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog INITIAL.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT test-file ASSIGN path
                        ORGANIZATION LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE	            SECTION.
       FD  test-file.
       01  test-rec     PIC X(5).
       LOCAL-STORAGE    SECTION.
       01  path         PIC X(10) VALUE "test.txt".
       PROCEDURE        DIVISION.
           OPEN INPUT test-file
           READ test-file   END-READ
           IF test-rec NOT = "hello"
              DISPLAY test-rec END-DISPLAY
           END-IF
           CLOSE test-file
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN with BASED data-item])
AT_KEYWORDS([runfile file status])

AT_DATA([TEST-FILE],
[hello
])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT test-file ASSIGN path
                        ORGANIZATION LINE SEQUENTIAL.
       DATA             DIVISION.
       FILE	            SECTION.
       FD  test-file.
       01  test-rec     PIC X(5).
       WORKING-STORAGE  SECTION.
       01  path         BASED PIC X(10).
       01  x            PIC X.
       PROCEDURE        DIVISION CHAINING x.
           IF x NOT = SPACES
              ALLOCATE path
              MOVE "TEST-FILE" TO path
              OPEN INPUT test-file
              FREE path
           ELSE
              OPEN INPUT test-file
           END-IF
           READ test-file   END-READ
           IF test-rec NOT = "hello"
              DISPLAY test-rec END-DISPLAY
           END-IF
           CLOSE test-file
           STOP RUN.
])

AT_DATA([prog2.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog2.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT test-file ASSIGN path
                        ORGANIZATION LINE SEQUENTIAL
                        FILE STATUS TEST-STAT.
       DATA             DIVISION.
       FILE	            SECTION.
       FD  test-file.
       01  test-rec     PIC X(5).
       WORKING-STORAGE  SECTION.
       01  path         BASED PIC X(10).
       01  test-stat    PIC X(2) VALUE "XX".
       PROCEDURE        DIVISION.
           OPEN INPUT test-file
           IF TEST-STAT NOT = '31'
              DISPLAY 'BAD OPEN, STATUS "' test-stat '"' END-DISPLAY
           END-IF
           READ test-file   END-READ
           IF TEST-STAT NOT = '47'
              DISPLAY 'BAD READ, STATUS "' test-stat '"' END-DISPLAY
           END-IF
           CLOSE test-file
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob])
AT_CHECK([$COBCRUN_DIRECT ./prog X], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [1], [],
[libcob: prog.cob:23: inconsistant file name (status = 31) file: 'test-file'
libcob: prog.cob:23: ASSIGN field with NULL address
])

AT_CHECK([$COMPILE prog2.cob])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [0], [], [])

AT_CLEANUP


AT_SETUP([ASSIGN with data-item in LINKAGE])
AT_KEYWORDS([runfile FILE-CONTROL file status])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.
       01  f-path     PIC X(80) VALUE "fooasg.txt".
       01  x-path     PIC X(80) VALUE "foxasg.txt".
       01  y-path     PIC X(80) VALUE "foyasg.txt".
       01  REC1       PIC 9(4) VALUE 1.
       01  REC2       PIC 9(4) VALUE 2.
       01  CUST-STAT  PIC X(2) VALUE "XX".

       PROCEDURE DIVISION.
           CALL "TSTOPN"  USING OMITTED.
           CALL "TSTOPN"  USING y-path.
           CALL "TSTOPEN" USING f-path  REC1 CUST-STAT.
           CALL "TSTOPEN" USING x-path  REC1 CUST-STAT.
           CALL "TSTOPEN" USING OMITTED REC1 CUST-STAT.
           CALL "TSTOPEN" USING f-path  REC2 CUST-STAT.
           CALL "TSTOPEN" USING x-path  REC2 CUST-STAT.
           STOP RUN.
           END PROGRAM prog.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. TSTOPEN.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN s-path
           ORGANIZATION RELATIVE
           ACCESS IS RANDOM
           RELATIVE KEY IS REC-NUM
           FILE STATUS IS CUST-STAT.

       DATA DIVISION.
       FILE SECTION.
       FD  f.
       01  f-line PIC X(79).

       WORKING-STORAGE SECTION.
       01  z-path   PIC X(80) VALUE "foozzz.txt".

       LINKAGE SECTION.
       01  s-path     PIC X(80).
       01  REC-NUM    PIC 9(4).
       01  CUST-STAT  PIC X(2).

       PROCEDURE DIVISION USING s-path, REC-NUM, CUST-STAT.
           IF ADDRESS OF s-path = NULL
              SET ADDRESS OF s-path TO ADDRESS OF z-path
           END-IF.
           IF REC-NUM > 1
              OPEN I-O f
              DISPLAY "Extend file: " s-path(1:10)
                   " - " CUST-STAT " #" REC-NUM "."
           ELSE
              OPEN OUTPUT f
              DISPLAY "Output file: " s-path(1:10)
                   " - " CUST-STAT " #" REC-NUM "."
           END-IF.
           IF CUST-STAT NOT = "00"
               DISPLAY "Opened error: " CUST-STAT "."
               GOBACK
           END-IF.
           MOVE "Hello World" TO f-line.
           MOVE REC-NUM       TO f-line (20:4).
           WRITE f-line.
           IF CUST-STAT NOT = "00"
               DISPLAY "WRITE error: " CUST-STAT "."
           END-IF.
           CLOSE f.
           GOBACK.
       END PROGRAM TSTOPEN.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. TSTOPN.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN s-path
           ORGANIZATION LINE SEQUENTIAL
           FILE STATUS IS IO-STS.

       DATA DIVISION.
       FILE SECTION.
       FD  f.
       01  f-line PIC X(80).

       WORKING-STORAGE SECTION.
       01  IO-STS   PIC X(2) VALUE "00".

       LINKAGE SECTION.
       01  s-path   PIC X(80).

       PROCEDURE DIVISION USING s-path.
           OPEN OUTPUT f
           IF IO-STS NOT = "00"
               DISPLAY "Opened error: " IO-STS "."
               GOBACK
           END-IF.
           DISPLAY "Opened file: " s-path(1:10) ".".
           MOVE "Hello World" TO f-line.
           WRITE f-line.
           CLOSE f.
           GOBACK.
       END PROGRAM TSTOPN.
])

AT_DATA([prog2.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog2.

       ENVIRONMENT DIVISION.
       DATA DIVISION.
       WORKING-STORAGE SECTION.

       PROCEDURE DIVISION.
           CALL "TSTOPEN" USING OMITTED.
           STOP RUN.
           END PROGRAM prog2.

       IDENTIFICATION DIVISION.
       PROGRAM-ID. TSTOPEN.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT f ASSIGN s-path
           ORGANIZATION SEQUENTIAL.

       DATA DIVISION.
       FILE SECTION.
       FD  f.
       01  f-line PIC X(79).

       LINKAGE SECTION.
       01  s-path     PIC X(80).

       PROCEDURE DIVISION USING s-path.
           OPEN OUTPUT f
           GOBACK.
       END PROGRAM TSTOPEN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Opened error: 31.
Opened file: foyasg.txt.
Output file: fooasg.txt - 00 #0001.
Output file: foxasg.txt - 00 #0001.
Output file: foozzz.txt - 00 #0001.
Extend file: fooasg.txt - 00 #0002.
Extend file: foxasg.txt - 00 #0002.
], [])

AT_CHECK([$COMPILE prog2.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog2], [1], [],
[libcob: prog2.cob:32: inconsistant file name (status = 31) file: 'f'
libcob: prog2.cob:32: ASSIGN field with NULL address
])

AT_CLEANUP


AT_SETUP([INDEXED File Sparse/Split keys])
AT_KEYWORDS([runfile split key sparse suppress])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.

       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT TSPFILE
           ASSIGN TO "testisam"
           ORGANIZATION INDEXED ACCESS DYNAMIC
           RECORD KEY IS PRIME-KEY
           SOURCE IS CM-CUST-NUM, CM-COMPANY

           ALTERNATE RECORD KEY IS SPLIT-KEY2
           SOURCE IS CM-TELEPHONE,CM-MACHINE WITH DUPLICATES

           ALTERNATE RECORD KEY IS SPLIT-KEY3
           SOURCE IS CM-DISK,CM-TAPE WITH DUPLICATES
                SUPPRESS WHEN ALL "*"
           FILE STATUS IS CUST-STAT
           .

       DATA  DIVISION.
       FILE SECTION.
       FD  TSPFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           05  TSPFL-REC.
           10  CM-CUST-NUM                     PICTURE X(8).
           10  CM-STATUS                       PICTURE X.
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-ADDRESS-1                    PICTURE X(25).
           10  CM-ADDRESS-2                    PICTURE X(25).
           10  CM-ADDRESS-3                    PICTURE X(25).
           10  CM-TELEPHONE                    PICTURE 9(10).
           10  CM-DP-MGR                       PICTURE X(25).
           10  CM-MACHINE                      PICTURE X(8).
           10  CM-MEMORY                       PICTURE X(4).
           10  CM-DISK                         PICTURE X(8).
           10  CM-TAPE                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(5).

       WORKING-STORAGE SECTION.

       01  CUST-STAT.
           05  STAT-1 PICTURE 9(4) COMP SYNC.
           05  FILLER REDEFINES STAT-1.
               10  STAT-X1 PIC X COMP-X.
               10  STAT-X2 PIC X COMP-X.
       77  BYTE-1  PICTURE 9(3).
       77  BYTE-2  PICTURE 9(3).
       77  MAX-SUB           VALUE  16         PICTURE 9(5) COMP SYNC.

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.

           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "GAM00000".
           05  FILLER PIC X(8) VALUE "DEL00000".
           05  FILLER PIC X(8) VALUE "EPS00000".
           05  FILLER PIC X(8) VALUE "FOR00000".
           05  FILLER PIC X(8) VALUE "GIB00000".
           05  FILLER PIC X(8) VALUE "H&J00000".
           05  FILLER PIC X(8) VALUE "INC00000".
           05  FILLER PIC X(8) VALUE "JOH00000".
           05  FILLER PIC X(8) VALUE "KON00000".
           05  FILLER PIC X(8) VALUE "LEW00000".
           05  FILLER PIC X(8) VALUE "MOR00000".
           05  FILLER PIC X(8) VALUE "NEW00000".
           05  FILLER PIC X(8) VALUE "OLD00000".
           05  FILLER PIC X(8) VALUE "PRE00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS 16.
         02  DATA-COMPANY-TBL.

           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
           05  FILLER PIC X(25) VALUE "EPSILON EQUIPMENT SUPPLY ".
           05  FILLER PIC X(25) VALUE "FORTUNE COOKIE COMPANY   ".
           05  FILLER PIC X(25) VALUE "GIBRALTER LIFE INSURANCE ".
           05  FILLER PIC X(25) VALUE "H & J PLUMBING SUPPLIES  ".
           05  FILLER PIC X(25) VALUE "INCREMENTAL BACKUP CORP. ".
           05  FILLER PIC X(25) VALUE "JOHNSON BOATING SUPPLIES ".
           05  FILLER PIC X(25) VALUE "KONFLAB PLASTIC PRODUCTS.".
           05  FILLER PIC X(25) VALUE "LEWISTON GRAPHICS LTD.   ".
           05  FILLER PIC X(25) VALUE "MORNINGSIDE CARPENTRY.   ".
           05  FILLER PIC X(25) VALUE "NEW WAVE SURF SHOPS INC. ".
           05  FILLER PIC X(25) VALUE "OLD TYME PIZZA MFG. CO.  ".
           05  FILLER PIC X(25) VALUE "PRESTIGE OFFICE FURNITURE".

         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS 16.
         02  DATA-ADDRESS-1-TBL.

           05  FILLER PIC X(25) VALUE "123 MAIN STREET          ".
           05  FILLER PIC X(25) VALUE "1090 2ND AVE. WEST       ".
           05  FILLER PIC X(25) VALUE "1401 JEFFERSON BLVD.     ".
           05  FILLER PIC X(25) VALUE "1620 ARIZONA WAY         ".
           05  FILLER PIC X(25) VALUE "1184 EAST FIRST STREET   ".
           05  FILLER PIC X(25) VALUE "114 JOHN F. KENNEDY AVE. ".
           05  FILLER PIC X(25) VALUE "650 LIBERTY CRESCENT     ".
           05  FILLER PIC X(25) VALUE "77 SUNSET BLVD.          ".
           05  FILLER PIC X(25) VALUE "10908 SANTA MONICA BLVD. ".
           05  FILLER PIC X(25) VALUE "1134 PARIS ROAD          ".
           05  FILLER PIC X(25) VALUE "808 NORTHWEST MAIN ST.   ".
           05  FILLER PIC X(25) VALUE "9904 QUEEN STREET        ".
           05  FILLER PIC X(25) VALUE "1709 DUNDAS CRESCENT W.  ".
           05  FILLER PIC X(25) VALUE "3240 MARIS AVENUE        ".
           05  FILLER PIC X(25) VALUE "1705 WISCONSIN ROAD      ".
           05  FILLER PIC X(25) VALUE "114A MAPLE GROVE         ".

         02  DATA-ADDRESS-1 REDEFINES DATA-ADDRESS-1-TBL
                                       PIC X(25) OCCURS 16.
         02  DATA-ADDRESS-2-TBL.

           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
           05  FILLER PIC X(10) VALUE "CALGARY   ".
           05  FILLER PIC X(10) VALUE "SAN DIEGO ".
           05  FILLER PIC X(10) VALUE "LOS RIOS  ".
           05  FILLER PIC X(10) VALUE "MADISON   ".
           05  FILLER PIC X(10) VALUE "WILBUR    ".
           05  FILLER PIC X(10) VALUE "TOPEKA    ".
           05  FILLER PIC X(10) VALUE "SEATTLE   ".
           05  FILLER PIC X(10) VALUE "NEW JERSEY".
           05  FILLER PIC X(10) VALUE "FORT WAYNE".
           05  FILLER PIC X(10) VALUE "COLUMBUS  ".
           05  FILLER PIC X(10) VALUE "RICHMOND  ".
           05  FILLER PIC X(10) VALUE "WHITEPLAIN".

         02  DATA-ADDRESS-2 REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS 16.
         02  DATA-ADDRESS-3-TBL.

           05  FILLER PIC X(10) VALUE "N.Y.      ".
           05  FILLER PIC X(10) VALUE "GEORGIA   ".
           05  FILLER PIC X(10) VALUE "D.C.      ".
           05  FILLER PIC X(10) VALUE "CANADA    ".
           05  FILLER PIC X(10) VALUE "CANADA    ".
           05  FILLER PIC X(10) VALUE "CALIFORNIA".
           05  FILLER PIC X(10) VALUE "NEW MEXICO".
           05  FILLER PIC X(10) VALUE "WISCONSIN ".
           05  FILLER PIC X(10) VALUE "DELAWARE  ".
           05  FILLER PIC X(10) VALUE "KANSAS    ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "N.J.      ".
           05  FILLER PIC X(10) VALUE "COLORADO  ".
           05  FILLER PIC X(10) VALUE "OHIO      ".
           05  FILLER PIC X(10) VALUE "VIRGINIA  ".
           05  FILLER PIC X(10) VALUE "N.Y.      ".

         02  DATA-ADDRESS-3 REDEFINES DATA-ADDRESS-3-TBL
                                       PIC X(10) OCCURS 16.
         02  DATA-TELEPHONE-TBL.

           05  FILLER PIC 9(10) VALUE 3131234432.
           05  FILLER PIC 9(10) VALUE 4082938498.
           05  FILLER PIC 9(10) VALUE 8372487274.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 5292398745.
           05  FILLER PIC 9(10) VALUE 8009329492.
           05  FILLER PIC 9(10) VALUE 6456445643.
           05  FILLER PIC 9(10) VALUE 6546456333.
           05  FILLER PIC 9(10) VALUE 3455445444.
           05  FILLER PIC 9(10) VALUE 6456445643.
           05  FILLER PIC 9(10) VALUE 7456434355.
           05  FILLER PIC 9(10) VALUE 6554456433.
           05  FILLER PIC 9(10) VALUE 4169898509.
           05  FILLER PIC 9(10) VALUE 7534587453.
           05  FILLER PIC 9(10) VALUE 8787458374.
           05  FILLER PIC 9(10) VALUE 4169898509.

         02  DATA-TELEPHONE REDEFINES DATA-TELEPHONE-TBL
                                       PIC 9(10) OCCURS 16.
         02  DATA-DP-MGR-TBL.

           05  FILLER PIC X(20) VALUE "MR. DAVE HARRIS     ".
           05  FILLER PIC X(20) VALUE "MS. JANICE SILCOX   ".
           05  FILLER PIC X(20) VALUE "MR. ALLAN JONES     ".
           05  FILLER PIC X(20) VALUE "MR. PETER MACKAY    ".
           05  FILLER PIC X(20) VALUE "MRS. DONNA BREWER   ".
           05  FILLER PIC X(20) VALUE "MR. MICHAEL SMYTHE  ".
           05  FILLER PIC X(20) VALUE "MR. D.A. MORRISON   ".
           05  FILLER PIC X(20) VALUE "MR. BRIAN PATTERSON ".
           05  FILLER PIC X(20) VALUE "MR. DARRYL TOWNSEND ".
           05  FILLER PIC X(20) VALUE "MS. VALERIE HARPER  ".
           05  FILLER PIC X(20) VALUE "MR. FRED MILLER     ".
           05  FILLER PIC X(20) VALUE "MR. DONALD FISCHER  ".
           05  FILLER PIC X(20) VALUE "MR. STEVEN YOURDIN  ".
           05  FILLER PIC X(20) VALUE "MS. Goldie Hawn     ".
           05  FILLER PIC X(20) VALUE "MS. ALICE WINSTON   ".
           05  FILLER PIC X(20) VALUE "MR. THOMAS JEFFERSON".

         02  DATA-DP-MGR    REDEFINES DATA-DP-MGR-TBL
                                       PIC X(20) OCCURS 16.
         02  DATA-MACHINE-TBL.

           05  FILLER PIC X(8) VALUE "UNI-9030".
           05  FILLER PIC X(8) VALUE "UNI-9040".
           05  FILLER PIC X(8) VALUE "UNI-80/3".
           05  FILLER PIC X(8) VALUE "UNI-80/5".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/6".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-80/8".
           05  FILLER PIC X(8) VALUE "UNI-9040".
           05  FILLER PIC X(8) VALUE "UNI-9040".

         02  DATA-MACHINE   REDEFINES DATA-MACHINE-TBL
                                       PIC X(8) OCCURS 16.
         02  DATA-NO-TERMINALS-TBL.

           05  FILLER PIC 9(3) COMP-3 VALUE 85.
           05  FILLER PIC 9(3) COMP-3 VALUE 34.
           05  FILLER PIC 9(3) COMP-3 VALUE 75.
           05  FILLER PIC 9(3) COMP-3 VALUE 45.
           05  FILLER PIC 9(3) COMP-3 VALUE 90.
           05  FILLER PIC 9(3) COMP-3 VALUE 107.
           05  FILLER PIC 9(3) COMP-3 VALUE 67.
           05  FILLER PIC 9(3) COMP-3 VALUE 32.
           05  FILLER PIC 9(3) COMP-3 VALUE 16.
           05  FILLER PIC 9(3) COMP-3 VALUE 34.
           05  FILLER PIC 9(3) COMP-3 VALUE 128.
           05  FILLER PIC 9(3) COMP-3 VALUE 64.
           05  FILLER PIC 9(3) COMP-3 VALUE 110.
           05  FILLER PIC 9(3) COMP-3 VALUE 324.
           05  FILLER PIC 9(3) COMP-3 VALUE 124.
           05  FILLER PIC 9(3) COMP-3 VALUE 86.

         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(3) COMP-3 OCCURS 16.

       01  WORK-AREA.
           05  REC-NUM                         PICTURE 9(6) VALUE 0.
           05  REC-MAX                         PICTURE 9(6) VALUE 10.
           05  SUB                             PICTURE 9(4) COMP SYNC.
               88  ODD-RECORD                  VALUE 1 3 5 7 9 10 11.
               88  NULL-KEY                    VALUE 4 5 8 12 14.

           05  TSPFL-KEY                       PICTURE X(8).

       PROCEDURE DIVISION.

       MAINFILE.
           PERFORM LOADFILE.
           PERFORM LISTFILE.
           STOP RUN.

       LOADFILE.
           DISPLAY "Loading sample data file."
                            UPON CONSOLE.

           OPEN OUTPUT TSPFILE
           IF CUST-STAT NOT = "00"
               DIVIDE STAT-1 BY 256 GIVING BYTE-1 REMAINDER BYTE-2
               DISPLAY "Error " CUST-STAT " " BYTE-1 " " BYTE-2
               " opening 'testisam' file"
                                UPON CONSOLE
               STOP RUN
           END-IF.

           PERFORM 1000-LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB.

           DISPLAY "Sample data file load complete."
                            UPON CONSOLE.
           CLOSE TSPFILE.

      *---------------------------------------------------------------*
      *         LOAD A RECORD FROM DATA TABLES                        *
      *---------------------------------------------------------------*

       1000-LOAD-RECORD.

           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE CM-CUST-NUM                  TO TSPFL-KEY.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-ADDRESS-1     (SUB)     TO CM-ADDRESS-1.
           MOVE DATA-ADDRESS-2     (SUB)     TO CM-ADDRESS-2.
           MOVE DATA-ADDRESS-3     (SUB)     TO CM-ADDRESS-3.
           MOVE DATA-TELEPHONE     (SUB)     TO CM-TELEPHONE.
           MOVE DATA-DP-MGR        (SUB)     TO CM-DP-MGR.
           MOVE DATA-MACHINE       (SUB)     TO CM-MACHINE.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.

           IF  ODD-RECORD
               MOVE "8417"                   TO CM-DISK
               MOVE "1600 BPI"               TO CM-TAPE
               MOVE "1MEG"                   TO CM-MEMORY
           ELSE
               MOVE "8470"                   TO CM-DISK
               MOVE "6250 BPI"               TO CM-TAPE
               MOVE "3MEG"                   TO CM-MEMORY.
           IF  NULL-KEY
               MOVE ALL "*"                  TO CM-DISK
               MOVE ALL "*"                  TO CM-TAPE.

           WRITE TSPFL-RECORD.
           IF CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Key: " TSPFL-KEY ", Status: " CUST-STAT
                                 UPON CONSOLE.

       LISTFILE.
           DISPLAY "LIST SAMPLE FILE" UPON CONSOLE.
           MOVE ZERO TO REC-NUM
           OPEN INPUT TSPFILE
           IF CUST-STAT NOT = "00"
               DISPLAY "ERROR " CUST-STAT " OPENING INPUT FILE "
                                             UPON CONSOLE
               IF CUST-STAT (1:1) = "9"
                   DISPLAY "Sub Error " STAT-X2 UPON CONSOLE
               END-IF
               STOP RUN
           END-IF.
           MOVE SPACES                       TO TSPFL-RECORD.
           START TSPFILE KEY GREATER THAN PRIME-KEY
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               IF CUST-STAT (1:1) = "9"
                   DISPLAY "Sub Error " STAT-X2 UPON CONSOLE
               END-IF
               STOP RUN
           END-IF.
           READ  TSPFILE NEXT RECORD WITH NO LOCK
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               IF CUST-STAT (1:1) = "9"
                   DISPLAY "Sub Error " STAT-X2 UPON CONSOLE
               END-IF
               STOP RUN
           END-IF.
           PERFORM UNTIL CUST-STAT NOT = "00"
                      OR REC-NUM > REC-MAX
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK ":"
                         UPON CONSOLE
               READ TSPFILE NEXT RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM
           IF CUST-STAT = "99"
               DISPLAY "Hit End of File" UPON CONSOLE
           END-IF.

           DISPLAY "LIST SAMPLE FILE DESCENDING" UPON CONSOLE.
           MOVE ZERO TO REC-NUM
           START TSPFILE KEY LESS THAN PRIME-KEY
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           READ  TSPFILE PREVIOUS RECORD WITH NO LOCK
           IF CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           PERFORM UNTIL CUST-STAT NOT = "00"
                      OR REC-NUM > REC-MAX
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK ":"
                         UPON CONSOLE
               READ TSPFILE PREVIOUS RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM.

           DISPLAY "LIST SAMPLE FILE BY KEY3" UPON CONSOLE.
           MOVE ZERO                         TO REC-NUM
           MOVE SPACES                       TO TSPFL-RECORD.
           START TSPFILE KEY GREATER THAN OR EQUAL TO SPLIT-KEY3
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " starting file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           READ  TSPFILE NEXT RECORD WITH NO LOCK
           IF  CUST-STAT NOT = "00"
           AND CUST-STAT NOT = "02"
               DISPLAY "Error " CUST-STAT " on 1st read of file"
                                UPON CONSOLE
               STOP RUN
           END-IF.
           PERFORM UNTIL (CUST-STAT NOT = "00"
                      AND CUST-STAT NOT = "02")
                      OR REC-NUM > REC-MAX
               DISPLAY "Key: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK ":"
                         UPON CONSOLE
               READ TSPFILE NEXT RECORD
                    AT END
                        MOVE "99" TO CUST-STAT
                END-READ
                ADD 1 TO REC-NUM
           END-PERFORM.
      *---- Some results may be different with VB-ISAM  ------*
           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (2)       TO CM-CUST-NUM.
           READ TSPFILE KEY IS PRIME-KEY
           IF  CUST-STAT NOT = "23"
               DISPLAY "Error " CUST-STAT " instead of 23"
                                UPON CONSOLE
           END-IF.
           MOVE DATA-COMPANY       (2)       TO CM-COMPANY.
           READ TSPFILE KEY IS PRIME-KEY
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on primary read "
                                UPON CONSOLE
           ELSE
               DISPLAY "Got: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK ":"
                         UPON CONSOLE
           END-IF.
           READ TSPFILE NEXT RECORD
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " on next read "
                                UPON CONSOLE
           ELSE
               DISPLAY "Nxt: " CM-CUST-NUM " is " CM-COMPANY
                        " Disk=" CM-DISK ":"
                         UPON CONSOLE
           END-IF.
           MOVE DATA-TELEPHONE     (7)       TO CM-TELEPHONE.
           MOVE DATA-MACHINE       (7)       TO CM-MACHINE.
           READ TSPFILE KEY IS SPLIT-KEY2
           IF  CUST-STAT NOT = "00"
               DISPLAY "Error " CUST-STAT " instead of 23"
                                UPON CONSOLE
           ELSE
               DISPLAY "Ky2: " CM-CUST-NUM " is " CM-COMPANY
                        " Mach=" CM-MACHINE ":"
                         UPON CONSOLE
           END-IF.
           CLOSE TSPFILE.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Loading sample data file.
Sample data file load complete.
LIST SAMPLE FILE
Key: ALP00000 is ALPHA ELECTRICAL CO. LTD. Disk=8417    :
Key: BET00000 is BETA SHOE MFG. INC.       Disk=8470    :
Key: DEL00000 is DELTA LUGGAGE REPAIRS     Disk=********:
Key: EPS00000 is EPSILON EQUIPMENT SUPPLY  Disk=********:
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=8470    :
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    :
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    :
Key: H&J00000 is H & J PLUMBING SUPPLIES   Disk=********:
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    :
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    :
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    :
LIST SAMPLE FILE DESCENDING
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    :
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    :
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    :
Key: H&J00000 is H & J PLUMBING SUPPLIES   Disk=********:
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    :
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    :
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=8470    :
Key: EPS00000 is EPSILON EQUIPMENT SUPPLY  Disk=********:
Key: DEL00000 is DELTA LUGGAGE REPAIRS     Disk=********:
Key: BET00000 is BETA SHOE MFG. INC.       Disk=8470    :
Key: ALP00000 is ALPHA ELECTRICAL CO. LTD. Disk=8417    :
LIST SAMPLE FILE BY KEY3
Key: ALP00000 is ALPHA ELECTRICAL CO. LTD. Disk=8417    :
Key: GAM00000 is GAMMA X-RAY TECHNOLOGY    Disk=8417    :
Key: GIB00000 is GIBRALTER LIFE INSURANCE  Disk=8417    :
Key: INC00000 is INCREMENTAL BACKUP CORP.  Disk=8417    :
Key: JOH00000 is JOHNSON BOATING SUPPLIES  Disk=8417    :
Key: KON00000 is KONFLAB PLASTIC PRODUCTS. Disk=8417    :
Key: BET00000 is BETA SHOE MFG. INC.       Disk=8470    :
Key: FOR00000 is FORTUNE COOKIE COMPANY    Disk=8470    :
Key: MOR00000 is MORNINGSIDE CARPENTRY.    Disk=8470    :
Key: OLD00000 is OLD TYME PIZZA MFG. CO.   Disk=8470    :
Key: PRE00000 is PRESTIGE OFFICE FURNITURE Disk=8470    :
Got: BET00000 is BETA SHOE MFG. INC.       Disk=8470    :
Nxt: DEL00000 is DELTA LUGGAGE REPAIRS     Disk=********:
Ky2: GIB00000 is GIBRALTER LIFE INSURANCE  Mach=UNI-80/6:
], [])

AT_CLEANUP


AT_SETUP([INDEXED File variable length record])
AT_KEYWORDS([runfile WRITE START READ])

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [
       Identification division.
       Program-id. prog.
      *
       Environment division.

       Input-output section.
       File-control.
      *
           Select optional tbw
               assign to path-tbw
               organization is indexed
               access mode is dynamic
               record key is tbw-key
               alternate record key is tbw-alt
                   suppress when space
               sharing with no other
               file status is fs-file-status.
      *
       I-o-control.
      *
       Data division.
       File section.
      *
       FD  tbw
           record is varying in size
               from 107 to 362 characters
               depending on end-tbw-record
	       .
       01  tbw-record.
           02 tbw-key                        pic x(100).
           02 tbw-alt.
               03 tbw-alt-1                  pic 9(02).
               03 tbw-alt-2                  pic 9(04).
           02 tbw-f1                         pic x(01).
           02 tbw-f2                         pic x(255).
      *
       Working-storage section.

       01  fs-file-status                 pic x(02).

       01  end-tbw-record                 pic 9(09) binary.

       01  flag-tbw                       pic x(01) value low-value.
           88 flag-tbw-open   value high-value.
           88 flag-tbw-closed value low-value.

       01  path-tbw                       pic x(255) value space.

       Procedure division.

      * Prepare.
           Move "tbw" to path-tbw.

      * First test.
           Perform tbw-delete-file thru tbw-exit.

           Perform tbw-open-i-o    thru tbw-exit.

           Move low-values to tbw-key.
           Perform tbw-start-primary-greater thru tbw-exit.

           Perform tbw-read-next thru tbw-exit.

           Move 122 to end-tbw-record.
           Move "aaaaa" to tbw-key.
           Move spaces to tbw-alt
                          tbw-f1
                          tbw-f2.
           Perform tbw-write thru tbw-exit.

           Move low-values to tbw-alt.
           Perform tbw-start-alternate thru tbw-exit.

           Move low-values to tbw-key.
           Perform tbw-start-primary-greater thru tbw-exit.

           Perform tbw-read-next thru tbw-exit.

           Perform tbw-read-next thru tbw-exit.

      * Second test.
           Perform tbw-close thru tbw-exit.

           Perform tbw-delete-file thru tbw-exit.

           Perform tbw-open-i-o thru tbw-exit.

           Move low-values to tbw-key.
           Perform tbw-start-primary-greater thru tbw-exit.

           Perform tbw-read-next thru tbw-exit.

           Move 163 to end-tbw-record.
           Move "aaaaa" to tbw-key.
           Move 1 to tbw-alt-1
                     tbw-alt-2.
           Move spaces to tbw-f1
                          tbw-f2.
           Perform tbw-write thru tbw-exit.

           Move 122 to end-tbw-record.
           Move "aaaab" to tbw-key.
           Move spaces to tbw-alt
                          tbw-f1
                          tbw-f2.
           Perform tbw-write thru tbw-exit.

           Move low-values to tbw-alt.
           Perform tbw-start-alternate thru tbw-exit.

           Perform tbw-read-next thru tbw-exit.

           Move spaces to tbw-alt.
           Perform tbw-rewrite thru tbw-exit.

      * Finish.
           Perform tbw-close thru tbw-exit.
           Display "Test completed".
           Stop run.

      * I/O.
       tbw-Open-I-O.
           If flag-tbw-open
               Perform tbw-Close thru tbw-Close-exit
           end-if.
           Display "open".
           Open i-o tbw.
           Display "open".
           If fs-file-status is less than "10"
               Set flag-tbw-open to true
           end-if.
           Go to tbw-exit.
      *
       tbw-Start-Primary-Greater.
           Display "start > tbw-key".
           Start tbw
               key is greater than tbw-key
               invalid key Continue
           end-start.
           Display "start > tbw-key".
           Go to tbw-exit.
      *
       tbw-Start-Alternate.
           Display "start >= tbw-alt".
           Start tbw
               key is not less than tbw-alt
               invalid key Continue
           end-start.
           Display "start >= tbw-alt".
           Go to tbw-exit.
      *
       tbw-Read-Next.
           Display "read next".
           Read tbw
               next record
               at end Continue
           end-read.
           Display "read next done".
           Go to tbw-exit.
      *
       tbw-Write.
           Display "write".
           Write tbw-record
               invalid key Continue
           end-write.
           Display "write".
           Go to tbw-exit.
      *
       tbw-Rewrite.
           Display "rewrite".
           Rewrite tbw-record
               invalid key Continue
           end-rewrite.
           Display "rewrite " fs-file-status.
           Go to tbw-exit.
      *
       tbw-Delete-File.
           If flag-tbw-open
               Perform tbw-Close thru tbw-Close-exit
           end-if.
           Move "xx" to fs-file-status.
           Display "delete file".
           Delete file tbw
           end-delete.
           Display "delete file".
           Go to tbw-exit.
      *
       tbw-Close.
           If flag-tbw-open
               Display "close"
               Close tbw
               Display "close"
               Set flag-tbw-closed to true
           end-if.
       tbw-Close-exit.
           Exit.
       tbw-exit.
           Exit.
])

AT_CHECK([$COMPILE prog.cob ], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[delete file
delete file
open
open
start > tbw-key
start > tbw-key
read next
read next done
write
write
start >= tbw-alt
start >= tbw-alt
start > tbw-key
start > tbw-key
read next
read next done
read next
read next done
close
close
delete file
delete file
open
open
start > tbw-key
start > tbw-key
read next
read next done
write
write
write
write
start >= tbw-alt
start >= tbw-alt
read next
read next done
rewrite
rewrite 00
close
close
Test completed
], [])

AT_CLEANUP


AT_SETUP([INDEXED sample])
AT_KEYWORDS([runfile optional file status READ WRITE DUPLICATES START])

# modified version of GC-FAQ: indexing example
# Author: Brian Tiffin, Date:   17-Feb-2009, 28-Jan-2014

AT_SKIP_IF([test "$COB_HAS_ISAM" = "no"])

AT_DATA([prog.cob], [

       identification division.
       program-id. linage.

       environment division.
       configuration section.

       input-output section.
       file-control.
          select optional indexed-file
          assign to "indexed-file.dat"
          status is indexing-status
          organization is indexed
          access mode is dynamic
          record key is keyfield of indexing-record
          alternate record key is altkey of indexing-record
              with duplicates
          .

       data division.
       file section.
       fd indexed-file.
       01 indexing-record.
          03 keyfield          pic x(8).
          03 filler            pic x.
          03 altkey.
             05 first-part     pic 99.
             05 middle-part    pic x.
             05 last-part      pic 99.
          03 filler            pic x.
          03 data-part         pic x(18).

       working-storage section.
       01 indexing-status.
          03 high-status-code  pic xx.
          03 high-status redefines high-status-code pic 99.
             88 indexing-ok              values 0 thru 10.
          03 low-status-code   pic xx.
          03 low-status redefines low-status-code pic 99.

       78 line-separator       value
           '-----------------------------------------'.
       01 display-record.
          03 filler            pic x(4)  value spaces.
          03 keyfield          pic x(8).
          03 filler            pic xx    value spaces.
          03 altkey.
             05 first-part     pic 99.
             05 filler         pic x     value space.
             05 middle-part    pic x.
             05 filler         pic x     value space.
             05 last-part      pic 99.
          03 filler            pic xx    value ", ".
          03 data-part         pic x(18).

      *> control break
       01 oldkey               pic 99x99.

      *> read control fields
       01 duplicate-flag       pic x.
          88 no-more-duplicates          value high-value
             when set to false                 low-value.
       01 record-flag          pic x.
          88 no-more-records             value high-value
             when set to false                 low-value.

      *> ***************************************************************
       procedure division.
       main.
      *> Populate a sample database, create or overwrite keys
           perform populate-sample

      *> clear the record space for this example
           move spaces to indexing-record

      *> open the data file again
           open i-o indexed-file
           perform indexing-check
           if not indexing-ok
             stop run returning 1
           end-if

      *> read all the duplicate 00b02 keys
           move 00 to first-part of indexing-record
           move "b" to middle-part of indexing-record
           move 02 to last-part of indexing-record

      *> using read key and then next key / last key compare
           set no-more-duplicates to false

           display "Read all 00b02 keys sequentially" end-display
           perform read-indexing-record
           perform read-next-record
               until no-more-duplicates
           display line-separator end-display

      *> read by key of reference ... the cool stuff
           move 00 to first-part of indexing-record
           move "a" to middle-part of indexing-record
           move 02 to last-part of indexing-record
           set no-more-records to false

      *> using start and read next
           display "Read all alternate keys greater than 00a02"
           end-display
           perform start-at-key
           perform read-next-by-key
               until no-more-records
           display line-separator end-display

      *> read by primary key of reference
           move "87654321" to keyfield of indexing-record
           set no-more-records to false

      *> using start and previous by key
          display
              "Read all primary keys less than "
              function trim (keyfield of indexing-record)
          end-display
          perform start-prime-key
          perform read-previous-by-key
              until no-more-records
          display line-separator end-display

      *> and with that we are done with indexing sample
          close indexed-file

          goback
          .
      *> ***************************************************************

      *> ***************************************************************
      *><* read by alternate key paragraph
       read-indexing-record.
           display "Reading: " altkey of indexing-record end-display
           read indexed-file key is altkey of indexing-record
               invalid key
                   display
                       "bad read key: "
                       function trim (altkey of indexing-record)
                       upon syserr
                   end-display
               set no-more-duplicates to true
           end-read
           perform indexing-check
           .

      *><* read next sequential paragraph
       read-next-record.
           move corresponding indexing-record to display-record
           display display-record end-display
           move altkey of indexing-record to oldkey

           read indexed-file next record
               at end set no-more-duplicates to true
               not at end
                   if oldkey not equal altkey of indexing-record
                       set no-more-duplicates to true
                   end-if
           end-read
           perform indexing-check
           .

      *><* start primary key of reference paragraph
       start-prime-key.
           display "Prime < " keyfield of indexing-record end-display
           start indexed-file
              key is less than
                  keyfield of indexing-record
              invalid key
                  display
                      "bad start: "
                      function trim (keyfield of indexing-record)
                      upon syserr
                  end-display
                  set no-more-records to true
              not invalid key
                  read indexed-file previous record
                      at end set no-more-records to true
                  end-read
           end-start
           perform indexing-check
           .

      *><* read previous by key of reference paragraph
       read-previous-by-key.
           move corresponding indexing-record to display-record
           display display-record end-display

           read indexed-file previous record
               at end set no-more-records to true
           end-read
           perform indexing-check
           .
      *><* start alternate key of reference paragraph
       start-at-key.
           display "Seeking >= " altkey of indexing-record end-display
           start indexed-file
              key is greater than or equal to
                  altkey of indexing-record
              invalid key
                  display
                      "bad start: "
                      function trim (altkey of indexing-record)
                      upon syserr
                  end-display
                  set no-more-records to true
              not invalid key
                  read indexed-file next record
                      at end set no-more-records to true
                  end-read
           end-start
           perform indexing-check
           .

      *><* read next by key of reference paragraph
       read-next-by-key.
           move corresponding indexing-record to display-record
           display display-record end-display

           read indexed-file next record
               at end set no-more-records to true
           end-read
           perform indexing-check
           .

      *><* populate a sample database
       populate-sample.

      *> Open optional index file for read write
           open i-o indexed-file
           perform indexing-check

           move "12345678 00a01 some 12345678 data" to indexing-record
           perform write-indexing-record
           move "87654321 00a01 some 87654321 data" to indexing-record
           perform write-indexing-record
           move "12348765 00a01 some 12348765 data" to indexing-record
           perform write-indexing-record
           move "87651234 00a01 some 87651234 data" to indexing-record
           perform write-indexing-record

           move "12345679 00b02 some 12345679 data" to indexing-record
           perform write-indexing-record
           move "97654321 00b02 some 97654321 data" to indexing-record
           perform write-indexing-record
           move "12349765 00b02 some 12349765 data" to indexing-record
           perform write-indexing-record
           move "97651234 00b02 some 97651234 data" to indexing-record
           perform write-indexing-record

           move "12345689 00c13 some 12345689 data" to indexing-record
           perform write-indexing-record
           move "98654321 00c13 some 98654321 data" to indexing-record
           perform write-indexing-record
           move "12349865 00c13 some 12349865 data" to indexing-record
           perform write-indexing-record
           move "98651234 00c13 some 98651234 data" to indexing-record
           perform write-indexing-record

      *> close it ... not necessary, but for the example we will
           close indexed-file
           perform indexing-check
           .

      *><* Write paragraph
       write-indexing-record.
           write indexing-record
               invalid key
                   display
                       "rewriting key: "
                       function trim (keyfield of indexing-record)
                       upon syserr
                   end-display
                   rewrite indexing-record
                       invalid key
                           display
                               "really bad key: "
                             function trim (keyfield of indexing-record)
                               upon syserr
                           end-display
                   end-rewrite
           end-write
           .

      *><* file status quick check.  For this sample, keep running
       indexing-check.
           if not indexing-ok then
               display
                   "isam file io problem: " indexing-status
                   upon syserr
               end-display
           end-if
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([rm -f "indexed-file.*"], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Read all 00b02 keys sequentially
Reading: 00b02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
-----------------------------------------
Read all alternate keys greater than 00a02
Seeking >= 00a02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
    12345689  00 c 13, some 12345689 data
    98654321  00 c 13, some 98654321 data
    12349865  00 c 13, some 12349865 data
    98651234  00 c 13, some 98651234 data
-----------------------------------------
Read all primary keys less than 87654321
Prime < 87654321
    87651234  00 a 01, some 87651234 data
    12349865  00 c 13, some 12349865 data
    12349765  00 b 02, some 12349765 data
    12348765  00 a 01, some 12348765 data
    12345689  00 c 13, some 12345689 data
    12345679  00 b 02, some 12345679 data
    12345678  00 a 01, some 12345678 data
-----------------------------------------
], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Read all 00b02 keys sequentially
Reading: 00b02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
-----------------------------------------
Read all alternate keys greater than 00a02
Seeking >= 00a02
    12345679  00 b 02, some 12345679 data
    97654321  00 b 02, some 97654321 data
    12349765  00 b 02, some 12349765 data
    97651234  00 b 02, some 97651234 data
    12345689  00 c 13, some 12345689 data
    98654321  00 c 13, some 98654321 data
    12349865  00 c 13, some 12349865 data
    98651234  00 c 13, some 98651234 data
-----------------------------------------
Read all primary keys less than 87654321
Prime < 87654321
    87651234  00 a 01, some 87651234 data
    12349865  00 c 13, some 12349865 data
    12349765  00 b 02, some 12349765 data
    12348765  00 a 01, some 12348765 data
    12345689  00 c 13, some 12345689 data
    12345679  00 b 02, some 12345679 data
    12345678  00 a 01, some 12345678 data
-----------------------------------------
],
[rewriting key: 12345678
rewriting key: 87654321
rewriting key: 12348765
rewriting key: 87651234
rewriting key: 12345679
rewriting key: 97654321
rewriting key: 12349765
rewriting key: 97651234
rewriting key: 12345689
rewriting key: 98654321
rewriting key: 12349865
rewriting key: 98651234
])

AT_CLEANUP


AT_SETUP([WRITE+REWRITE FILE name])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.

       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT FLATFILE ASSIGN EXTERNAL RELFIX
           ORGANIZATION RELATIVE
           ACCESS IS SEQUENTIAL RELATIVE KEY IS REC-NUM
           FILE STATUS IS CUST-STAT.

           SELECT FLATFILE2 ASSIGN EXTERNAL RELFIX
           ORGANIZATION RELATIVE
           ACCESS IS RANDOM RELATIVE KEY IS REC-NUM
           FILE STATUS IS CUST-STAT.

       DATA  DIVISION.
       FILE SECTION.
       FD  FLATFILE
           BLOCK CONTAINS 5 RECORDS.

       01  TSPFL-RECORD.
           10  CM-CUST-NUM                     PICTURE X(8).
           10  CM-COMPANY                      PICTURE X(25).
           10  CM-DISK                         PICTURE X(8).
           10  CM-NO-TERMINALS                 PICTURE 9(4).

       FD  FLATFILE2
           BLOCK CONTAINS 5 RECORDS.

       01  TSP2-RECORD.
           10  C2-CUST-NUM                     PICTURE X(8).
           10  C2-COMPANY                      PICTURE X(25).
           10  C2-DISK                         PICTURE X(8).
           10  C2-NO-TERMINALS                 PICTURE 9(4).

       WORKING-STORAGE SECTION.

       77  MAX-SUB           VALUE  6          PICTURE 9(4) COMP SYNC.
       77  CUST-STAT                           PICTURE X(2).
       77  REC-NUM           VALUE  1          PICTURE 9(4).

       01  TEST-DATA.

         02  DATA-CUST-NUM-TBL.

           05  FILLER PIC X(8) VALUE "ALP00000".
           05  FILLER PIC X(8) VALUE "BET00000".
           05  FILLER PIC X(8) VALUE "DEL00000".
           05  FILLER PIC X(8) VALUE "EPS00000".
           05  FILLER PIC X(8) VALUE "FOR00000".
           05  FILLER PIC X(8) VALUE "GAM00000".

         02  DATA-CUST-NUM REDEFINES DATA-CUST-NUM-TBL
                                       PIC X(8) OCCURS 6.
         02  DATA-COMPANY-TBL.

           05  FILLER PIC X(25) VALUE "ALPHA ELECTRICAL CO. LTD.".
           05  FILLER PIC X(25) VALUE "BETA SHOE MFG. INC.      ".
           05  FILLER PIC X(25) VALUE "DELTA LUGGAGE REPAIRS    ".
           05  FILLER PIC X(25) VALUE "EPSILON EQUIPMENT SUPPLY ".
           05  FILLER PIC X(25) VALUE "FORTUNE COOKIE COMPANY   ".
           05  FILLER PIC X(25) VALUE "GAMMA X-RAY TECHNOLOGY   ".
         02  DATA-COMPANY  REDEFINES DATA-COMPANY-TBL
                                       PIC X(25) OCCURS 6.
         02  DATA-ADDRESS-2-TBL.

           05  FILLER PIC X(10) VALUE "ATLANTA   ".
           05  FILLER PIC X(10) VALUE "CALGARY   ".
           05  FILLER PIC X(10) VALUE "NEW YORK  ".
           05  FILLER PIC X(10) VALUE "TORONTO   ".
           05  FILLER PIC X(10) VALUE "WASHINGTON".
           05  FILLER PIC X(10) VALUE "WHITEPLAIN".
         02  DATA-ADDRESS   REDEFINES DATA-ADDRESS-2-TBL
                                       PIC X(10) OCCURS 6.

         02  DATA-NO-TERMINALS-TBL.

           05  FILLER PIC 9(3) COMP-3 VALUE 10.
           05  FILLER PIC 9(3) COMP-3 VALUE 13.
           05  FILLER PIC 9(3) COMP-3 VALUE 75.
           05  FILLER PIC 9(3) COMP-3 VALUE 10.
           05  FILLER PIC 9(3) COMP-3 VALUE 90.
           05  FILLER PIC 9(3) COMP-3 VALUE 254.

         02  DATA-NO-TERMINALS REDEFINES DATA-NO-TERMINALS-TBL
                                       PIC 9(3) COMP-3 OCCURS 6.
       01  WORK-AREA.
           05  SUB                             PICTURE 9(4) COMP SYNC.
               88  ODD-RECORD                  VALUE 1 3 5.


       PROCEDURE DIVISION.

           PERFORM LOADFILE.

           OPEN I-O FLATFILE2.
           MOVE 2 TO REC-NUM
           READ FLATFILE2
           DISPLAY "Read    " C2-CUST-NUM " Sts:" CUST-STAT
                   " Trms:" C2-NO-TERMINALS.
           ADD 1 TO C2-NO-TERMINALS
           REWRITE FILE FLATFILE2 FROM TSP2-RECORD
           READ FLATFILE2
           DISPLAY "REWROTE " C2-CUST-NUM " Sts:" CUST-STAT
                   " Trms:" C2-NO-TERMINALS.
           CLOSE FLATFILE2.
           STOP RUN.

       LOADFILE.
           DISPLAY "Loading sample program data file."
                            UPON CONSOLE.

           OPEN OUTPUT FLATFILE.

           PERFORM LOAD-RECORD
                        VARYING SUB FROM 1 BY 1
                          UNTIL SUB > MAX-SUB.

           DISPLAY "Sample program data file load complete."
                            UPON CONSOLE.
           CLOSE FLATFILE.

       LOAD-RECORD.

           MOVE SPACES                       TO TSPFL-RECORD.
           MOVE DATA-CUST-NUM      (SUB)     TO CM-CUST-NUM.
           MOVE DATA-COMPANY       (SUB)     TO CM-COMPANY.
           MOVE DATA-NO-TERMINALS  (SUB)     TO CM-NO-TERMINALS.
           IF  ODD-RECORD
               MOVE "8417"                   TO CM-DISK
           ELSE
               MOVE "8470"                   TO CM-DISK.
           WRITE FILE FLATFILE FROM TSPFL-RECORD.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[Loading sample program data file.
Sample program data file load complete.
Read    BET00000 Sts:00 Trms:0013
REWROTE BET00000 Sts:00 Trms:0014
], [])

AT_CLEANUP

AT_SETUP([START RELATIVE (1)])
AT_KEYWORDS([fundamental runfile DELETE FILE])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT OPTIONAL TEST-FILE
              ASSIGN      "TESTFILE"
              ACCESS       DYNAMIC
              ORGANIZATION RELATIVE
              STATUS       TESTSTAT
              RELATIVE KEY TESTKEY
       .
       DATA             DIVISION.
       FILE             SECTION.
       FD  TEST-FILE.
       01  TEST-REC     PIC X(4).
       WORKING-STORAGE  SECTION.
       01  TESTKEY      USAGE BINARY-LONG UNSIGNED.
       01  TESTSTAT     PIC XX.
           88  V-OK     VALUE "00" "05".
       PROCEDURE        DIVISION.
           DELETE FILE TEST-FILE.
           OPEN  I-O   TEST-FILE.
           IF NOT V-OK
              DISPLAY "OPEN " TESTSTAT
              END-DISPLAY
              GOBACK
           END-IF.
           MOVE 99 TO TESTKEY.
           START TEST-FILE KEY < TESTKEY
           END-START.
           IF TESTSTAT NOT = "23"
              DISPLAY "START " TESTSTAT
              END-DISPLAY
           END-IF.
           CLOSE TEST-FILE.
       END PROGRAM prog.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([START RELATIVE (2)])
AT_KEYWORDS([fundamental runfile DELETE FILE])

AT_DATA([prog.cob], [
       IDENTIFICATION   DIVISION.
       PROGRAM-ID.      prog.
       ENVIRONMENT      DIVISION.
       INPUT-OUTPUT     SECTION.
       FILE-CONTROL.
       SELECT OPTIONAL TEST-FILE
              ASSIGN      "TESTFILE"
              ACCESS       DYNAMIC
              ORGANIZATION RELATIVE
              STATUS       TESTSTAT
              RELATIVE KEY TESTKEY
       .
       DATA             DIVISION.
       FILE             SECTION.
       FD  TEST-FILE.
       01  TEST-REC     PIC X(4).
       WORKING-STORAGE  SECTION.
       01  TESTKEY      USAGE BINARY-LONG UNSIGNED.
       01  TESTSTAT     PIC XX.
           88  V-OK     VALUE "00" "05".
           88  V-ZERO   VALUE "00".
       PROCEDURE        DIVISION.
           DELETE FILE TEST-FILE.
           OPEN  I-O   TEST-FILE.
           IF NOT V-OK
              DISPLAY "OPEN " TESTSTAT
              END-DISPLAY
              GOBACK
           END-IF.
           MOVE 3 TO TESTKEY.
           MOVE "0003" TO TEST-REC.
           WRITE TEST-REC INVALID KEY
                 DISPLAY "WRITE " TESTSTAT
                 END-DISPLAY
           END-WRITE.
           MOVE 2 TO TESTKEY.
           MOVE "0002" TO TEST-REC.
           WRITE TEST-REC INVALID KEY
                 DISPLAY "WRITE " TESTSTAT
                 END-DISPLAY
           END-WRITE.
           MOVE 99 TO TESTKEY.
           START TEST-FILE KEY < TESTKEY
           END-START.
           IF NOT V-ZERO
              DISPLAY "START " TESTSTAT
              END-DISPLAY
           END-IF.
           IF TESTKEY NOT = 99
              DISPLAY "TESTKEY " TESTKEY
              END-DISPLAY
           END-IF.
           MOVE  SPACE TO TEST-REC.
           READ  TEST-FILE NEXT
           END-READ.
           IF NOT V-ZERO
              DISPLAY "READ " TESTSTAT
              END-DISPLAY
           END-IF.
           IF TEST-REC NOT = "0003"
              DISPLAY "READ RECORD " TEST-REC
              END-DISPLAY
           END-IF.
           CLOSE TEST-FILE.
       END PROGRAM prog.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([READ on OPTIONAL missing file])
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.
       ENVIRONMENT DIVISION.
       CONFIGURATION SECTION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT OPTIONAL INFILE  ASSIGN TO
                "missing.txt"
                ORGANIZATION IS RELATIVE
                ACCESS IS SEQUENTIAL
                FILE STATUS IS WSFS.
       DATA DIVISION.
       FILE SECTION.
       FD  INFILE.
       01  INREC             PIC X(80).
       WORKING-STORAGE SECTION.
       01  WSFS           PIC X(2).
           88  RECORDFOUND VALUE "00".
       01  WSINREC         PIC X(80).
       PROCEDURE DIVISION.
       MAIN-PROCEDURE.
      *    Open missing file
           OPEN INPUT INFILE
      *    First read, raise a FS 10 (AT END) which is expected
           READ INFILE INTO WSINREC
           END-READ
           IF WSFS = '10'
              DISPLAY "1st READ on missing optional file = " WSFS " OK"
           ELSE
              DISPLAY "1st READ on missing optional file = " WSFS " Bad"
           END-IF.

      *    Second read, should raise a FS 46 (READ AFTER AT END)
      *    but a FS 23 is raised instead.
           READ INFILE INTO WSINREC
           END-READ

           IF WSFS = '46'
              DISPLAY "2nd READ on missing optional file = " WSFS " OK"
           ELSE
              DISPLAY "2nd READ on missing optional file = " WSFS " Bad"
           END-IF.

           CLOSE INFILE
           STOP RUN.
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])

AT_CHECK([$COBCRUN_DIRECT ./prog], [0],
[1st READ on missing optional file = 10 OK
2nd READ on missing optional file = 46 OK
], [])

AT_CLEANUP


AT_SETUP([EXTERNAL RELATIVE file])
# FIXME: Check the function of the EXTERNAL file using a second program, too
AT_KEYWORDS([runfile])

AT_DATA([prog.cob], [
       IDENTIFICATION DIVISION.
       PROGRAM-ID. prog.

       ENVIRONMENT DIVISION.
       INPUT-OUTPUT SECTION.
       FILE-CONTROL.
           SELECT my-file
               ASSIGN TO "somefile"
               ORGANIZATION IS RELATIVE
               RELATIVE KEY IS my-key.

       DATA DIVISION.
       FILE SECTION.
       FD my-file EXTERNAL.
       01 my-record.
           03 my-record-data PIC X(80).

       WORKING-STORAGE SECTION.
       01  my-key PIC 9.

       PROCEDURE DIVISION.
           CONTINUE
           .
])

AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])

AT_CLEANUP


AT_SETUP([System routines for directories])
AT_KEYWORDS([extensions runfile CBL_CREATE_DIR CBL_CHANGE_DIR CBL_DELETE_DIR])

AT_DATA([prog.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        01 DIR PIC X(4) VALUE 'ABCD'.

        PROCEDURE DIVISION.
        CALL 'CBL_CREATE_DIR' USING DIR END-CALL
        IF RETURN-CODE NOT = 0
            DISPLAY 'error creating dir ...' END-DISPLAY
        END-IF

        CALL 'CBL_CHANGE_DIR' USING DIR END-CALL
        IF RETURN-CODE NOT = 0
            DISPLAY 'error changing dir ...' END-DISPLAY
        END-IF

        CALL 'CBL_CHANGE_DIR' USING '..' END-CALL
        IF RETURN-CODE NOT = 0
            DISPLAY 'error changing dir up ...' END-DISPLAY
        END-IF

        CALL 'CBL_DELETE_DIR' USING DIR END-CALL
        IF RETURN-CODE NOT = 0
            DISPLAY 'error deleting dir' END-DISPLAY
        END-IF

        STOP RUN.
])


AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [], [])
AT_CHECK([test -e abcd], [1], [], [])

AT_CLEANUP


AT_SETUP([System routines for files])
AT_KEYWORDS([extensions runfile CBL_CREATE_FILE CBL_WRITE_FILE CBL_FLUSH_FILE
CBL_OPEN_FILE CBL_READ_FILE CBL_CLOSE_FILE CBL_RENAME_FILE CBL_DELETE_FILE
C$DELETE])

AT_DATA([file1], [
dummy
])
AT_DATA([file2], [
test
])
AT_DATA([file3], [
data
])

AT_DATA([prog.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID.     prog.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        01 FNAME        PIC X(256) VALUE 'testtext.txt'.
        01 ACCESS-MODE  PIC X      USAGE COMP-X VALUE 2.
        01 FHANDLE      PIC X(4)   USAGE COMP-X.

        01 OFFSET       PIC X(8)   USAGE COMP-X.
        01 NBYTES       PIC X(4)   USAGE COMP-X.
        01 WRITE-BUFFER PIC X(20).

        PROCEDURE DIVISION.
        CALL 'CBL_CREATE_FILE' USING FNAME 55 11 22 FHANDLE
        END-CALL
        IF RETURN-CODE NOT = -1
           DISPLAY 'Wrong return codes ...' END-DISPLAY
        END-IF
        MOVE 0 TO RETURN-CODE

        CALL 'CBL_CREATE_FILE' USING
        FNAME ACCESS-MODE 0 0 FHANDLE
        END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error creating file ...' END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        MOVE 'TestText.ABCD' TO WRITE-BUFFER.
        MOVE 0 TO OFFSET.
        MOVE 9 TO NBYTES.

        CALL 'CBL_WRITE_FILE' USING
        FHANDLE OFFSET NBYTES '0' WRITE-BUFFER
        END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error writing file ...' END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        CALL 'CBL_FLUSH_FILE' USING FHANDLE END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error flushing file ...' END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        CALL 'CBL_CLOSE_FILE' USING FHANDLE END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error closing file ...' END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        STOP RUN.
])

AT_DATA([prog2.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID.     prog2.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        01 FNAME        PIC X(256) VALUE 'testtext.txt'.
        01 RET          PIC -9.
        01 FHANDLE      PIC X(4)   USAGE COMP-X.

        01 OFFSET       PIC X(8)   USAGE COMP-X.
        01 NBYTES       PIC X(4)   USAGE COMP-X.
        01 READ-BUFFER  PIC X(10).

        PROCEDURE DIVISION.
        CALL 'CBL_OPEN_FILE' USING FNAME 1 0 0 FHANDLE
        END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error opening file ...' END-DISPLAY
        END-IF

        MOVE SPACES TO READ-BUFFER.
        MOVE 2 TO OFFSET.
        MOVE 9 TO NBYTES.

        CALL 'CBL_READ_FILE' USING
        FHANDLE OFFSET NBYTES 0 READ-BUFFER
        END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error reading file ...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF
        IF READ-BUFFER NOT = 'stText.' *> text from first test
           DISPLAY 'Wrong readbuffer ...' END-DISPLAY
        END-IF

        CALL 'CBL_CLOSE_FILE' USING FHANDLE END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error closing file ...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        CALL 'CBL_RENAME_FILE' USING FNAME 'foo.txt' END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error renaming file ...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF

        CALL 'CBL_DELETE_FILE' USING 'file1' END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error deleting file1 ...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF
        CALL 'CBL_DELETE_FILE' USING 'file1' END-CALL
        IF RETURN-CODE = 0
           DISPLAY 'no error on deleting file1 for the second time...'
                   return-code
           END-DISPLAY
        END-IF
        MOVE 0 TO RETURN-CODE

        CALL 'C$DELETE' USING 'file2' 'S' END-CALL
        IF RETURN-CODE NOT = 0
           DISPLAY 'error deleting file2 ...'
                   return-code
           END-DISPLAY
           MOVE 0 TO RETURN-CODE
        END-IF
        CALL 'CBL_DELETE_FILE' USING 'file2' END-CALL
        IF RETURN-CODE = 0   *> note: should only return 0 or 1 when in ACUCOBOL mode
           DISPLAY 'no error on deleting file2 for the second time...'
                   return-code
           END-DISPLAY
        END-IF
        MOVE 0 TO RETURN-CODE

        STOP RUN.
])


AT_CHECK([$COMPILE prog.cob], [0], [], [])
AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog], [0], [],
[libcob: prog.cob:15: warning: call to CBL_CREATE_FILE with wrong file_lock: 11
libcob: prog.cob:15: warning: call to CBL_CREATE_FILE with wrong file_dev: 22
libcob: prog.cob:15: warning: call to CBL_OPEN_FILE with wrong access mode: 55
])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [0], [], [])

AT_CLEANUP


AT_SETUP([System routine CBL_COPY_FILE])
AT_KEYWORDS([extensions runfile])

AT_DATA([prog.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        PROCEDURE DIVISION.
        DISPLAY "test" END-DISPLAY
        STOP RUN.
])

AT_DATA([prog2.cob], [
        IDENTIFICATION DIVISION.
        PROGRAM-ID. prog2.
        DATA DIVISION.
        WORKING-STORAGE SECTION.
        01 FILE1 PIC X(8) VALUE 'prog.cob'.
        01 FILE2 PIC X(9) VALUE 'prog3.cob'.

        PROCEDURE DIVISION.
        CALL 'CBL_COPY_FILE' USING
        FILE1 FILE2
        END-CALL
        STOP RUN.
])

AT_CHECK([$COMPILE prog2.cob], [0], [], [])
AT_CHECK([$COBCRUN_DIRECT ./prog2], [0], [], [])
AT_CHECK([diff prog.cob prog3.cob], [0], [], [])

AT_CLEANUP
